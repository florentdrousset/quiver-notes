{
  "title": "Symfony log",
  "cells": [
    {
      "type": "markdown",
      "data": "## Jeudi 5 Septembre"
    },
    {
      "type": "markdown",
      "data": "### Voters\nSymfony appelle tous les voteurs à chaque fois que la méthode `isGranted()` ou `denyAccessUnlessGranted()`est appelée. (les deux utilisent le __authorization checker__)\nA custom voter needs to implement `VoterInterface` or extend `Voter`, which makes creating a voter even easier.\n\n__Voter::supports($attribute, $subject)__ :\nQuand `isGranted()` ou `denyAccessUnlessGranted()` est appelé, le premier argument est passé en tant que `$attribute`(ex: ROLE_USER, edit...). Le second (s'il y en a un) est passé en tant que `$subject` (ex: Un objet Post, null...). Si on return `true`, c'est la méthode `voteOnAttribute` qui est appellée.\n\n__voteOnAttribute($attribute, $subject, TokenInterface $token)__ :\n\nOn écrit ensuite le code que l'on veut et on renvoie `true` si on veut autoriser l'accès, ou `false` si on veut l'interdire !\n\n__Résumé__ :\nisGranted()\n-> appelle Voter::supports\n-> true appelle voteOnAttribute\n-> true autorise l'accès.\n\nPour passer en environnement de prod, il suffit de changer la valeur de APP_ENV dans notre fichier .env à prod."
    },
    {
      "type": "markdown",
      "data": "## Mardi 27 Août\n\nOn continue les requêtes avancées sur [Doctrine](quiver-note-url/1D445A66-1F49-4416-B1CF-2BE3B8457824)"
    },
    {
      "type": "markdown",
      "data": "## Lundi 26 Août\n\nPrincipe de base des évènements :\nUn évènement est quelque chose qui se passe dans l'application (ex: un utilisateur s'inscrit)\nOn peut 'accrocher' des listeners ou des subscribers à cet évènement, qui réagiront à cet évènement (ex: envoi d'email, flashbag, etc...)\n\nAu lieu d'appeler notre évènement avec un //$dispatcher->addListener(RegisterEvent::NAME, [$listener, 'sendMailToUser']);\non peut aussi écrire la ligne suivante dans notre services.yaml :"
    },
    {
      "type": "code",
      "language": "yaml",
      "data": "    App\\EventListener\\RegisterListener :\n        tags:\n            - { name: kernel.event_listener, event: user.register, method: sendMailToUser, priority: -10 }"
    },
    {
      "type": "markdown",
      "data": "bin/console debug:event-dispatcher\n\n\nUn Listener va écouter un évènement. On la déclare soit avec un ->addListener, soit en ajoutant des tags dans notre services.yaml.\nAu lieu d'avoir des listeners, on peut avoir des _subscribers_.\nUn _subscriber_ va fonctionner comme un _listener_, sauf qu'il sera une sous-classe de _EventSubscriberInterface_.\nL'avantage des subscribers, c'est qu'on a plus à les déclarer comme services, c'est fait tout seul grâce à l'__autowiring__."
    },
    {
      "type": "code",
      "language": "php",
      "data": "class RegisterSubscriber implements EventSubscriberInterface\n{\n    public $session;\n\n    public function __construct(SessionInterface $session)\n    {\n        $this->session = $session;\n    }\n\n    public function sendMailToUser(RegisterEvent $e){\n        // Create the message\n        $message = (new \\Swift_Message())\n            // Add subject\n            ->setSubject('Here should be a subject')\n\n            //Put the From address\n            ->setFrom(['support@mailtrap.io'])\n            ->setTo($e->getUser()->getEmail())\n            ->setBody('yo !');\n\n        $this->mailer->send($message);\n    }\n\n    public function displayRegistrationMessage() {\n        $this->session->getFlashBag()->add('success', 'Vous êtes enregistré ! Bienvenue.');;\n    }\n\n    public static function getSubscribedEvents() {\n       return [\n           RegisterEvent::NAME => ['sendMailToUser', -10],\n           RegisterEvent::NAME => ['displayRegistrationMessage', 3]\n       ];\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "le controller doit uniquement gérer les entrées et sorties HTTP\n\nOn peut aussi s'accrocher sur tous les éléments du noyau. On pourrait par exemple imaginer un subscriber qui réagirait à l'évènement KernelEvents::RESPONSE.\nOn peut trouver tous les évènements du noyau dans `vendor/symfony/http-kernel/KernelEvents.php`\n\nOn a donc :\n1. Les évènements que l'on crée nous même\n2. Les évènements du noyau de Symfony\n\nDans le dispatcher, on a uniquement accès à la liste des évènements qui ont des écouteurs. On a malheureusement pas de méthode permettant de recenser tous les évènements.\nUne méthode pourrait être de faire une recherche sur toutes les classes étendant de la classe Event."
    },
    {
      "type": "markdown",
      "data": "### Cours Benoît Symfony\n\nCas d'utilisations des event listeners :\n1. Tout ce qui est complémentaire est appelé \"scénario alternatif\" -> envoyer un mail au client, etc... On peut \"brancher\" ou \"débrancher\" les évènements facilement. \n2. Et en cas de traitement répété, \"transversal\". Ex: si on fait quelque chose dans tous les controller, on pourrait plutôt créer un listener sur l'évènement Kernel::Controller.\n\nDonc un évènement :\nSoit transversal, soit traitement complémentaire.\n\n\"Make:entity et make:auth sont bien, le reste des générateurs non\"\ndonc pas de make:crud, etc.\n\nhttps://openclassrooms.com/fr/courses/2035826-debutez-lanalyse-logicielle-avec-uml/2035851-uml-c-est-quoi"
    },
    {
      "type": "markdown",
      "data": "### Exercice sur les requêtes Doctrine avancées\n\nOn veut faire un tableau de bord affichant des statistiques sur notre label.\nPar exemple :\n1. Le nombre de titres par genre\n2. Liste des pays des gens qui se sont inscrit depuis un mois\n3. Afficher les 10 artistes ayant participé au plus grand nombre d'évènements\n4. Montant moyen dépensé par client\n\nOn va s'aider de la [doc de Doctrine](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/dql-doctrine-query-language.html)\nSi les méthodes 'built-in' ne suffisent pas, on peut utiliser trois autres syntaxes :\n1. DQL (Doctrine Query Language) -> DQL as a query language has SELECT, UPDATE and DELETE constructs that map to their corresponding SQL statement types. Permet de faire une partie du SQL, mais pas tout. On récupère au final un tableau d'objets.\n2. [Query Builder](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/query-builder.html). Son intérêt est que l'on va construire des requêtes avec. "
    },
    {
      "type": "code",
      "language": "php",
      "data": "createQueryBuilder('u')\n->select(...)\n->where(...)\n->andWhere(...)\n\netc.\n//voir les exemples dans les Repository déjà créés par Symfony."
    },
    {
      "type": "markdown",
      "data": "3. Native SQL -> requête SQL -> ResultSetMapping. On va devoir déclarer explicitement la relation entre les paramètres de l'objet et les colonnes de notre table. Dans celles-ci on récupère des tableaux PHP."
    },
    {
      "type": "markdown",
      "data": "Binding parameters to your query\nDoctrine supports dynamic binding of parameters to your query, similar to preparing queries. You can use both strings and numbers as placeholders, although both have a slightly different syntax. Additionally, you must make your choice: Mixing both styles is not allowed. Binding parameters can simply be achieved as follows:\n"
    },
    {
      "type": "code",
      "language": "php",
      "data": "<?php\n// $qb instanceof QueryBuilder\n\n$qb->select('u')\n   ->from('User', 'u')\n   ->where('u.id = ?1')\n   ->orderBy('u.name', 'ASC')\n   ->setParameter(1, 100); // Sets ?1 to 100, and thus we will fetch a user with u.id = 100\n"
    },
    {
      "type": "markdown",
      "data": "You are not forced to enumerate your placeholders as the alternative syntax is available:"
    },
    {
      "type": "code",
      "language": "php",
      "data": "\n<?php\n// $qb instanceof QueryBuilder\n\n$qb->select('u')\n   ->from('User', 'u')\n   ->where('u.id = :identifier')\n   ->orderBy('u.name', 'ASC')\n   ->setParameter('identifier', 100); // Sets :identifier to 100, and thus we will fetch a user with u.id = 100"
    },
    {
      "type": "markdown",
      "data": "Note that numeric placeholders start with a ? followed by a number while the named placeholders start with a : followed by a string.\n\nCalling setParameter() automatically infers which type you are setting as value. This works for integers, arrays of strings/integers, DateTime instances and for managed entities. If you want to set a type explicitly you can call the third argument to setParameter() explicitly. It accepts either a PDO type or a DBAL Type name for conversion.\n\nIf you've got several parameters to bind to your query, you can also use setParameters() instead of setParameter() with the following syntax:"
    },
    {
      "type": "code",
      "language": "php",
      "data": "\n<?php\n// $qb instanceof QueryBuilder\n\n// Query here...\n$qb->setParameters(array(1 => 'value for ?1', 2 => 'value for ?2'));"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "## Vendredi 23 Août\n\nEvenements\n-> Kernel\n-> Application\n\nOn va les mettre dans un dossier `Event` de notre `src`.\nLes events sont traités par un dispatcher. \n\nen parallèle:\nphp composer.phar require swiftmailer\n\nOn crée une classe RegisterEvent :\n"
    },
    {
      "type": "code",
      "language": "php",
      "data": "<?php\n\n\nnamespace App\\Event;\nuse Symfony\\Contracts\\EventDispatcher\\Event;\n\nfinal class RegisterEvent extends Event\n{\n    public const NAME = 'user.register';\n    private $user;\n    public function __construct(User $user) {\n        $this->user = $user;\n    }\n\n    public function getUser() {\n        return $this->user;\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "Quand on crée un évènement, on peut y stocker des informations via le constructeur. On a un évènement, on peut donc le distribuer.\nSi on veut utiliser cet évènement. \n\nOn a enregistré un utilisateur. On veut ensuite que cela déclenche un évènement."
    },
    {
      "type": "code",
      "language": "php",
      "data": "$e = new RegisterEvent($user);\n$dispatcher->dispatch();\n$dispatch->addEventListener"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "## Jeudi 22 Août\n\nOn observe les caractéristiques d'un service à l'aide de la commande :\n`bin/console debug:container container`\n\n#### Service Id\nApp\\Hello\\HelloWorld;\n\ntroiswa.hello_world :\n  alias: App\\Hello\\HelloWorld\n  \n#### [Tag](https://openclassrooms.com/fr/courses/3619856-developpez-votre-site-web-avec-le-framework-symfony/3624937-les-services-utilisation-poussee)\n  \n#### Public\nSi on a besoin d'un service non injecté dans le constructeur, on peut l'appeler grâce à cette méthode, uniquement SI le service est public :\n`$this->get('App\\Hello\\HelloWorld);`\n\n#### Synthetic\nDans services.yaml, on peut définir en synthetic : true. (Utilité relative)\n\n#### [Lazy](https://symfony.com/doc/current/service_container/lazy_services.html)\n\nDichotomie __eager__ / __lazy__"
    },
    {
      "type": "code",
      "language": "php",
      "data": "if ($this->isSubmitted() && $this->isValid())"
    },
    {
      "type": "markdown",
      "data": "Ici en PHP, comportement paresseux. Si le submitted est faux, il ne va pas évaluer le second terme de la condition. En cas de comportement vorace (eager), l'interpréteur évaluerait tous les membres de l'expression. \n\nDans le cas des services, Symfony ne va charger des services dans le conteneur qu'en cas où il en aura besoin. (lazy)\n(Typiquement, Doctrine a aussi un comportement lazy)"
    },
    {
      "type": "markdown",
      "data": "#### Shared\n\nQuand on utilise un service, c'est toujours le même objet : il n'est jamais recréé. On peut aussi définir le shared sur \"no\", et dans ce cas là on instanciera un nouvel objet à chaque fois que le service est utilisé.\n\n-----\n\nPour injecter des services, on utilise classiquement l'injection de dépendance à travers le `__construct`. Cependant, on peut aussi le faire par les setters."
    },
    {
      "type": "code",
      "language": "php",
      "data": "public $container\n\npublic function setContainer(ContainerInterface $c) {\n  $this->container = $c;\n}\n\n...\n\n$s->container->getParameter($blabla)"
    },
    {
      "type": "markdown",
      "data": "Cela nous permet d'avoir des dépendances optionnelles."
    },
    {
      "type": "markdown",
      "data": "Dans notre fichier `services.yaml`, on peut définir des calls.\nhttps://symfony.com/doc/current/service_container/calls.html"
    },
    {
      "type": "code",
      "language": "yaml",
      "data": "    App\\Hello\\HelloWorld:\n        arguments:\n            $p: 'Hector'\n            $prenom: '%p1%'\n            #ici, le %p1% fait référence à notre paramètre p1\n\n        calls:"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "__Exercice__ : si on passe un nom d'image à notre service, on veut que celui-ci nous ressorte une présentation plus riche de cette image (avec un <figure>) par exemple. Exemple twig :"
    },
    {
      "type": "code",
      "language": "twig",
      "data": "{{ e.img | figure(e.description) | raw }}"
    },
    {
      "type": "markdown",
      "data": "Quand on écrira ça, cela insérera toute la structure HTML en question dans notre template. Si le texte est trop long, prend (par exemple) les 50 premiers caractères.\nDonc tout le code <img src=\"asset(truc)\"> sera remplacé par le code twig ci-dessus."
    },
    {
      "type": "markdown",
      "data": "Pour cela, on va écrire une [extension Twig](https://symfony.com/doc/current/templating/twig_extension.html)"
    },
    {
      "type": "markdown",
      "data": "Quand on fait hériter une classe de AbstractExtension, Symfony comprend qu'elle est une extension Twig.\nIl faut ensuite déclarer les filtres avec la fonction getFilters()"
    },
    {
      "type": "markdown",
      "data": "__Exercice__ : on a utilisé l'API Wiki"
    },
    {
      "type": "markdown",
      "data": "__Exercice__ :\npartie symfony : 1 route + 1 controller\nroute /artiste/{id}/sameStyle\n\npartie JS :\nroute de type /artiste/24/same-style"
    },
    {
      "type": "code",
      "language": "javascript",
      "data": "fetch().then(function(response))..."
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "## Mercredi 21 Août\n\n#### Services\nQuand Symfony démarre, l'une des premières choses qu'il fait est de construire le _conteneur de services_, qui gère toutes les dépendandes entre les différents services. "
    },
    {
      "type": "markdown",
      "data": "* Exercice : construction de notre premier service"
    },
    {
      "type": "markdown",
      "data": "Service qui va afficher sur la page d'accueil la chaîne de caractère qui nous sera fournie par le service. Dans le dossier src/, on crée un nouveau dossier /hello. Dans ce dossier, on crée un fichier HelloWorld.php. Ce fichier va contenir une classe HelloWorld, avec une méthode 'yo' qui renvoie 'yo'.  "
    },
    {
      "type": "markdown",
      "data": "Dans la méthode de notre controller, on peut directement __injecter des services__ en paramètres de notre méthode."
    },
    {
      "type": "code",
      "language": "php",
      "data": "class WelcomeController extends AbstractController {\n  //On passe notre service (classe) HelloWorld en argument, et on peut ensuite employer notre classe au sein de la méthode de notre controller\n    public function welcome(EventRepository $eventRepository, \\App\\Hello\\HelloWorld $h) {\n       return $this->render(\n           'index/indexView.html.twig', [\n               'event' => $eventRepository->findAll(),\n               'message' => $h->yo()\n           ]\n       );\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "Un ajout de service classique est le service Request."
    },
    {
      "type": "code",
      "language": "php",
      "data": "public function index(Request $request, $v1, $v2)"
    },
    {
      "type": "markdown",
      "data": "Dans le fichier __service.yaml__, on peut définir des \"constantes\" de projet appelés parameters. Entre %, on utilise des variables yaml."
    },
    {
      "type": "markdown",
      "data": "Pour y accéder, on utilise la méthode getParameter()."
    },
    {
      "type": "markdown",
      "data": "(Dans notre fichier .env, on peut aussi définir des constantes globales)"
    },
    {
      "type": "markdown",
      "data": "Dans notre service.yaml, on a ensuite la section 'services' qui contient la section 'default'."
    },
    {
      "type": "markdown",
      "data": "L'auto-\nwiring permet d'organiser la dépendance des services entre eux sans avoir à déclarer quoi que ce soit.\nL'autoconfigure "
    },
    {
      "type": "markdown",
      "data": "Dans notre App\\, on veut considérer que toutes les classes qui sont dans le dossier src sont considérées comme des services. "
    },
    {
      "type": "markdown",
      "data": "On peut obtenir une liste de tous les services de notre application avec la commande"
    },
    {
      "type": "code",
      "language": "php",
      "data": "bin/console debug:container"
    },
    {
      "type": "markdown",
      "data": "On peut aussi ajouter un nom de service ou une chaîne de caratère à la fin de cette commande pour rechercher un service en particulier. S'il n'y a qu'un seul nom de service qui correspond, on obtient des détails sur le service en question."
    },
    {
      "type": "markdown",
      "data": "On peut aussi associer des services à d'autres services (?) avec le système de tags."
    },
    {
      "type": "markdown",
      "data": "###### arguments\n-> constante\n-> service (dépendance)\n-> paramètre\n\n###### calls\n\n###### tags"
    },
    {
      "type": "markdown",
      "data": "On crée un constructeur dans notre service HelloWorld car on veut lui ajouter des paramètres. Problème : on n'instanciera jamais notre HelloWorld. Cest à cela que va nous service notre fichier de configuration services.yaml. On va lui ajouter une section !"
    },
    {
      "type": "code",
      "language": "yaml",
      "data": "App\\Hello\\HelloWorld:\n        arguments:\n            $p: 'Hector'"
    },
    {
      "type": "markdown",
      "data": "Grâce à ceci, l'argument $p de notre service sera 'Hector'."
    },
    {
      "type": "code",
      "language": "php",
      "data": "class HelloWorld {\n    private $name;\n\n    public function __construct(string $p)\n    {\n       $this->name = $p;\n    }\n\n    public function yo() {\n        return 'yo '.$this->name;\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "On pourrait également utiliser nos paramètres yaml :"
    },
    {
      "type": "code",
      "language": "yaml",
      "data": "    App\\Hello\\HelloWorld:\n        arguments:\n            $p: 'Hector'\n            $prenom: '%p1%'\n            #ici, le %p1% fait référence à notre paramètre p1"
    },
    {
      "type": "markdown",
      "data": "* Ex. 2 : On veut faire un service qui transforme une chaîne de caractères en maj, ou en minuscules... Et on veut que notre classe HelloWorld dépende de ce deuxième service.\n\nOn crée donc un deuxième service Magnifier."
    },
    {
      "type": "code",
      "language": "php",
      "data": "class Magnifier\n{\n    public function upper(string $s) {\n        return strtoupper($s);\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "On passe ensuite notre magnifier dans la signature du constructeur de notre service 'HelloWorld'. On peut ainsi utiliser notre magnifier au sein de notre service HelloWorld. "
    },
    {
      "type": "code",
      "language": "php",
      "data": "use App\\Magnifier\\Magnifier;\n\nclass HelloWorld {\n    private $name;\n    private $m;\n\n    public function __construct(string $p, string $prenom, Magnifier $m)\n    {\n       $this->name = $prenom;\n       $this->magnifier = $m;\n    }\n\n    public function yo() {\n        return 'yo '.$this->name;\n    }\n\n    public function yoUpper() {\n        return $this->magnifier->upper($this->yo());\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "L'injection de dépendances est complètement gérée par le conteneur de services de Symfony. Quand vous avez des services, Symfony observe la signature de la fonction et remarque que le service a besoin d'une instance de la classe magnifier. Si Symfony observe que cette classe est un service, il comprend que l'on a besoin d'une instance de cette classe, grâce à __l'autowire__ du conteneur de services.\n\nOn peut aussi passer un nom de service de la manière suivante :"
    },
    {
      "type": "code",
      "language": "yaml",
      "data": "$m: '@App\\HelloWorld\\NomDeService'"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "## Mardi 20 Août 2019"
    },
    {
      "type": "markdown",
      "data": "J'ai implémenté un système d'upload de fichier dans mes classes Event et Product. Plusieurs étapes pour cela, toutes tirées du [tutoriel de la doc Symfony](https://symfony.com/doc/current/controller/upload_file.html)\n1. Rajouter une "
    },
    {
      "type": "markdown",
      "data": "On regarde dans [Security.yaml](quiver-note-url/4E0DB276-8A3E-47B1-92B1-CE85F00C90FD)"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "make:user "
    },
    {
      "type": "markdown",
      "data": "-> Entity\n-> Repository __(classe de requête)__\n-> [Security.yaml](quiver-note-url/4E0DB276-8A3E-47B1-92B1-CE85F00C90FD)"
    },
    {
      "type": "markdown",
      "data": "providers\nusers:\nentity:\nclass:"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "make:entity"
    },
    {
      "type": "markdown",
      "data": "make:auth -> [Guard](https://symfony.com/doc/current/security/guard_authentication.html) -> LoginFormAuthenticator"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "make:registration-form"
    },
    {
      "type": "markdown",
      "data": " permet de créer un formulaire d'inscription."
    },
    {
      "type": "markdown",
      "data": "Les controllers de Symfony héritent de la classe Controller, qui elle même implémente le trait ControllerTrait. Dans celle-ci, on y trouve la méthode `$this->getUser()` qui permet de récupérer un utilisateur. Si personne n'est connecté, cela renvoie quand même un résultat. On va donc vouloir vérifier que ce qui est renvoyé est une instance de la classe User.\n\nOn a aussi une méthode `$this->isGranted('ROLE_ADMIN')`. Qui permet de savoir si l'utilisateur connecté possède tel ou tel rôle. (admin en l'occurence). Cette méthode peut aussi être remplacée par une annotation : `@IsGranted('ROLE_ADMIN')`"
    },
    {
      "type": "markdown",
      "data": "On a aussi une méthode `$this->denyAccessUnlessGranted('ROLE_ADMIN')`. Si la personne n'a pas le rôle Admin, on lui refuse l'accès et renvoie une erreur."
    },
    {
      "type": "markdown",
      "data": "---"
    },
    {
      "type": "markdown",
      "data": "On peut aussi utiliser un objet `app.user` ou `is_granted` directement dans [Twig](quiver-note-url/CDFDCD5D-97CC-4FAE-9B98-3B439ECCBDFF)"
    },
    {
      "type": "code",
      "language": "twig",
      "data": " {% if is_granted('ROLE_MANAGER') == false %}\n                  my message \n {% endif %}"
    },
    {
      "type": "code",
      "language": "php",
      "data": "$artist = $repository->find(25);\nreturn ... ['a' => $artist];\n// On aura donc accès à 'a' dans Twig."
    },
    {
      "type": "code",
      "language": "twig",
      "data": "{% for e in a.events %}\n{# on parcourt les évènements de l'artist. En tâche de fond, il se passe $artist->getEvents. On fait appel à Doctrine qui va faire une requête SQL. Au moment où cette ligne est executée, on relance une requête via le modèle ! #}\n{{ e.heureDebut }}\n{% endfor %}"
    },
    {
      "type": "markdown",
      "data": "[Twig](quiver-note-url/CDFDCD5D-97CC-4FAE-9B98-3B439ECCBDFF) récupère en fait les informations minimum de 'Artist', et récupèrera les infos à la volée via Doctrine au moment ou notre boucle Twig sera lue."
    },
    {
      "type": "markdown",
      "data": "----"
    },
    {
      "type": "markdown",
      "data": "3 niveaux de sécurité dans Symfony :\n- Security.yaml\n- Ce qu'on va mettre dans nos controllers\n- Voteurs"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "## Lundi 19 Août 2019"
    },
    {
      "type": "markdown",
      "data": "Création d'une page à partir d'une méthode d'un contrôleur grâce au [tutoriel de Symfony](https://symfony.com/doc/current/page_creation.html)\n\n"
    },
    {
      "type": "markdown",
      "data": "Création d'utilisateurs, 4 étapes :\n- Créer une (ou des) entité(s) utilisateur. -> Liée au noyau de Symfony\n- Gestion de la connexion\n- Configuration (dossier config) (voteurs -> ACL ((Access Control List))\n- Appeler les utilisateurs -> gestion des droits d'accès\n\nPour créer une entité user 'automatiquement', on peut utiliser la commande suivante :"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "bin/console make:user"
    },
    {
      "type": "markdown",
      "data": "Cela nous permet d'avoir une méthode getRole, getPassword, getSalt, getUsername, eraseCredentials..."
    },
    {
      "type": "code",
      "language": "sh",
      "data": "bin/console make:auth"
    },
    {
      "type": "markdown",
      "data": "En choisissant l'option login form, on pourra ensuite accéder à notre formulaire par l'URL /login"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "On peut aussi utiliser la commande\nbin/console make:registration-form"
    },
    {
      "type": "markdown",
      "data": "pour crééer un formulaire d'enregistrement."
    },
    {
      "type": "markdown",
      "data": "Les méthodes et routes login et logout se trouvent dans le SecurityController ainsi créé."
    },
    {
      "type": "markdown",
      "data": "On gère les rôles dans security.yaml"
    },
    {
      "type": "markdown",
      "data": "bin/console make:fixtures"
    },
    {
      "type": "markdown",
      "data": "https://github.com/fzaninotto/Fake"
    },
    {
      "type": "code",
      "language": "php",
      "data": "<?php\n\nnamespace App\\DataFixtures;\n\nuse App\\Entity\\Artist;\nuse App\\Entity\\Event;\nuse Doctrine\\Bundle\\FixturesBundle\\Fixture;\nuse Doctrine\\Common\\Persistence\\ObjectManager;\nuse Faker;\n\nclass AppFixtures extends Fixture\n{\n    public function load(ObjectManager $manager)\n    {\n        $faker = \\Faker\\Factory::create('fr_FR');\n        // $product = new Product();\n        // $manager->persist($product);\n        for($i = 0 ; $i < 10; $i++)\n        {\n            $artist = new Artist();\n            $artist->setNom($faker->name);\n            $artist->setPays($faker->country);\n            $artist->setStyle($faker->jobTitle);\n            $artist->setPresentation($faker->catchPhrase);\n            $manager->persist($artist);\n        }\n\n\n        for($i = 0 ; $i < 10; $i++)\n        {\n            $event = new Event();\n            $event->setType($faker->companySuffix);\n            $event->setDateDebut($faker->dateTime($max = 'now', $timezone = null));\n            $event->setDateFin($faker->dateTime($max = 'now', $timezone = null));\n            $event->setLieu($faker->company);\n            $event->setVille($faker->city);\n            $event->setDescription($faker->catchPhrase);\n            $event->setPrix($faker->numberBetween($min = 5, $max = 150));\n            $manager->persist($event);\n\n        }\n        \n\n        $manager->flush();\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "bin/console doctrine:fixtures:load --append"
    },
    {
      "type": "markdown",
      "data": "Le flag --append permet d'ajouter les données sans purger la base de données !"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "### Mardi 13 Août 2019"
    },
    {
      "type": "markdown",
      "data": "On installe un projet Symfony 4 avec la commande"
    },
    {
      "type": "markdown",
      "data": "Pour lancer le serveur :  php -S localhost:8000 -t public/"
    },
    {
      "type": "markdown",
      "data": "Contrairement à Symfony 3, il n'y a pas de DefaultController donc on commence sur une erreur 404."
    },
    {
      "type": "markdown",
      "data": "app.php -> production\napp_dev.php -> developpement"
    },
    {
      "type": "code",
      "language": "twig",
      "data": "composer create-project symfony/website-skeleton nom-de-projet"
    },
    {
      "type": "markdown",
      "data": "On peut utiliser \"make\" dans la console pour créer différentes choses, par exemple un contrôleur :"
    },
    {
      "type": "code",
      "language": "twig",
      "data": "bin/console make:controller"
    },
    {
      "type": "markdown",
      "data": "Projet maison de disques :"
    },
    {
      "type": "markdown",
      "data": "User stories. Acteur -> Moyen -> Action"
    },
    {
      "type": "markdown",
      "data": "![disque_diagramme.png](quiver-image-url/1B05B3D232BB40A60F612F754F6A5543.png =784x1028)"
    },
    {
      "type": "markdown",
      "data": "Après avoir créé notre diagrame, on veut créer les entités symfony correspondantes."
    },
    {
      "type": "code",
      "language": "twig",
      "data": " bin/console make:entity"
    },
    {
      "type": "markdown",
      "data": "Grâce à ça, on a créé une classe \"Artiste\" dans src/Entity et \"ArtisteRepository\" dans src/Repository."
    },
    {
      "type": "markdown",
      "data": "On créée ensuite la classe \"Evenement\" de la même manière. On veut lier notre classe \"Evenement\" à notre classe \"Artiste\". Pour cela, on lui rajoute un champ \"artiste_id\" avec le type \"relation\". On peut ensuite choisir \"manyToOne\" (par exemple). à la question"
    },
    {
      "type": "markdown",
      "data": " Do you want to add a new property to Artiste so that you can access/update Evenement objects from it - e.g. $artiste->getEvenements()? (yes/no) [yes]:\n"
    },
    {
      "type": "markdown",
      "data": ", si on répond oui, on peut aussi crééer une relation 1,n. Donc, requête doctrine qui permet de récupérer tous les évènements associés à un artiste."
    },
    {
      "type": "code",
      "language": "sh",
      "data": "Do you want to activate orphanRemoval on your relationship?\n A Evenement is \"orphaned\" when it is removed from its related Artiste.\n e.g. $artiste->removeEvenement($evenement)\n \n NOTE: If a Evenement may *change* from one Artiste to another, answer \"no\".\n\n Do you want to automatically delete orphaned App\\Entity\\Evenement objects (orphanRemoval)? (yes/no) [no]:\n"
    },
    {
      "type": "markdown",
      "data": "Dans ce cas, si on supprime un Artiste, on se retrouvera avec des évènements orphelins. Si on répond oui, doctrine supprimera automatiquement les évènements qui n'ont plus d'artistes. \"No\" est donc plus secure dans ce cas-là."
    },
    {
      "type": "markdown",
      "data": "__Généralement, on ne crée par la relation One to Many, mais la Many to One.__"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "bin/console doctrine:database:create\nbin/console doctrine:schema:create (ou update)"
    },
    {
      "type": "code",
      "language": "sh",
      "data": "bin/console make:crud Artist"
    },
    {
      "type": "markdown",
      "data": "On a eu une erreur sur le fait qu'Event voulait afficher Artist en string. Pour corriger le problème, on a implémenté la méthode __toString dans la classe Artiste pour corriger le problème."
    },
    {
      "type": "markdown",
      "data": "En lançant la commande _make:crud_, Symfony créée automatiquement les controllers et vues nécessaire. "
    },
    {
      "type": "markdown",
      "data": "Les classes de repository héritent de classes plus générales.\n->findAll() permet d'extraire toutes les données d'une table.\n->find(id) permet de sélectionner par l'id.\n->findBy('ville', 'bordeaux')\n->findByVille('bordeaux')\n\nDoctrine nous ramènera donc des objets.\n\nOn trouve également d'autres exemples dans nos classes Repository créées par défaut."
    },
    {
      "type": "markdown",
      "data": "Dans la classe ArtistController, on a également la méthode _new_."
    },
    {
      "type": "markdown",
      "data": "grâce au createForm, si on lui passe un objet $artist en deuxième paramètre, notre formulaire sera prérempli avec le contenu de cet objet."
    },
    {
      "type": "markdown",
      "data": "->handleRequest gère notre requête en POST, met les bonnes valeurs dans les bons objets, etc."
    },
    {
      "type": "markdown",
      "data": "On peut tester si un formulaire est submitted et s'il est valide. (classe de validation).\nSi tout est valide, grâce à la méthode persist de l'Entity manager, on previent doctrine que l'on est en train de créer un objet dans le mécanisme de persistence. (car notre objet existe dans le code PHP mais n'existe pas encore dans la base de données. On doit cependant prvenir doctrine qu'il doit déà être pris en compte.)"
    },
    {
      "type": "markdown",
      "data": "->flush() permet de remplir la base de données avec le contenu de notre objet."
    },
    {
      "type": "markdown",
      "data": "On fait ensuite une redirection HTTP avec la méthode redirectToRoute. "
    },
    {
      "type": "markdown",
      "data": "Pour créer la view qui correspond à notre formulaire, on passe à l'index 'array' la méthode $form->createView()."
    },
    {
      "type": "markdown",
      "data": "_Rappel_ : Dans Symfony, on ne manipule jamais les URL en temps que tel mais toujours les noms de route."
    },
    {
      "type": "markdown",
      "data": "#### Formulaires"
    },
    {
      "type": "markdown",
      "data": "Grâce au make:crud, Symfony a aussi créé des formulaires dans src/Form. "
    },
    {
      "type": "markdown",
      "data": "La méthode principale des formulaires est la méthode ->buildForm(). On ajoute des propriétés du $builder avec la méthode ->add()."
    },
    {
      "type": "markdown",
      "data": "Ne pas hésiter à lire la doc sur les [Form Types](https://symfony.com/doc/current/reference/forms/types/). Symfony est capable de comprender le type de données qu'on a défini en créant nos entités et créer le bon type de champ pour chaque champ du formulaire.\n"
    },
    {
      "type": "code",
      "language": "php",
      "data": "->add('artist_id', EntityType::class, [\n                'class' => Artist::class,\n                'choice_label' => 'name'\n            ])"
    },
    {
      "type": "markdown",
      "data": "Grâce à ca, on a plus a ajouter le toString dans notre controller Artist.aa---"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "### Lundi 12 Août 2019"
    },
    {
      "type": "markdown",
      "data": "Pour installer Symfony avec composer :"
    },
    {
      "type": "code",
      "language": "php",
      "data": "composer create-project symfony/framework-standard-edition"
    },
    {
      "type": "markdown",
      "data": "Déjà prêt à l'emploi, version \"old school\" avec des ressources en démonstration"
    },
    {
      "type": "code",
      "language": "php",
      "data": "symfony/website-skeleton"
    },
    {
      "type": "markdown",
      "data": "Un peu similaire à la première, mais pas d'exemples en particulier."
    },
    {
      "type": "code",
      "language": "php",
      "data": "symfony/skeleton"
    },
    {
      "type": "markdown",
      "data": "Version \"flex\" qui n'installe que le noyau minimum du framework."
    },
    {
      "type": "markdown",
      "data": "Nous sommes donc sur \"symfony/symfony\": \"3.4.30\". La page d'accueil se situant dans web/"
    },
    {
      "type": "markdown",
      "data": "(Site semver.org => bonne pratiques pour nommer les versions d'un logiciel.)"
    },
    {
      "type": "markdown",
      "data": "Versions standard et LTS(Long-Term Support). Pour symfony 2 : 2.7/2.8 Pour Symfony 3 : 3.4"
    },
    {
      "type": "markdown",
      "data": "Architecture Symfony\n* app : _config, resources:stocke les templates, erreurs personnalisées, etc._\n* bin : _executables, console de symfony_\n* src :\n* * AppBundle\n* * * Controller __C__\n* * * * DefaultController\n* * * Entity __M__\n* * Resources : contenant les fichiers de description du modèle __M__: ORM Object Relationship Manager (Doctrine), description du modèle, routage, templates twigs_ __V__\n* * Repository : va contenir les classes de requêtes_ __M__\n* tests : _tests unitaires/fonctionnels_\n* var : _cache & logs_\n* vendor : _noyau, bibliothèques tierces (packagist), bibliothèques de l'appli._\n* web : _point d'entrée public. S'appelle public dans les versions suivantes. CSS, JS..._"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "php bin/console pour lancer la console de symfony."
    },
    {
      "type": "markdown",
      "data": "Avant Symfony 3.3, Symfony était composé de bundles : unités peu fonctionnelles de manière autonome. (MVC)"
    },
    {
      "type": "markdown",
      "data": "Dans le dossier src, on a un \"AppBundle\", appellé à disparaître dans les versions ultérieures."
    },
    {
      "type": "markdown",
      "data": "Concept de \"services\" gérant tous les cas d'utilisations, traitement algorithmiques des données."
    },
    {
      "type": "markdown",
      "data": "Schéma simple d'une requête\nREQUÊTE => ROUTEUR => CONTRÔLEUR => MODELE -> Stockage\n                    -> React, Angular, Tw  -> Requêtes\n                                           -> [Persistance](quiver-note-url/8E89CBDD-7EF0-4447-A089-B5A493E7FEF9) (couche de). Permet à l'ORM de maintenir une cohérence entre l'application et les données stockées sur le disque\n                                           "
    },
    {
      "type": "markdown",
      "data": "![IMG_20190812_105736.jpg](quiver-image-url/54650D61DA69C85C2EF3009FA2047D95.jpg =3456x4608)"
    },
    {
      "type": "markdown",
      "data": "Comment Symfony affiche la première page d'accueil ? Grâce au DefaultController situé dans l'AppBundle/Controller (namespace AppBundle\\Controller)"
    },
    {
      "type": "code",
      "language": "php",
      "data": "<?php\n\nnamespace AppBundle\\Controller;\n\nuse Symfony\\Bundle\\FrameworkBundle\\Controller\\Controller;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\Routing\\Annotation\\Route;\n\nclass DefaultController extends Controller\n{\n    /**\n     * @Route(\"/\", name=\"homepage\")\n     */\n    public function indexAction(Request $request)\n    {\n        // replace this example code with whatever you need\n        return $this->render('default/index.html.twig', [\n            'base_dir' => realpath($this->getParameter('kernel.project_dir')).DIRECTORY_SEPARATOR,\n        ]);\n    }\n}"
    },
    {
      "type": "markdown",
      "data": "Ici, le routeur a déjà analysé la requête HTTP en amont. La variable $request est un objet contenant toute notre requête."
    },
    {
      "type": "markdown",
      "data": "La méthode 'render' va construire la vue. \n1er paramètre : lien vers la vue. Celui-ci se trouve dans le dossier app/resources/views\n2eme paramètre : tableau associatif. 'base_dir' va devenir une variable native dans notre template."
    },
    {
      "type": "markdown",
      "data": "L'annotation @Route lie l'URL écrite dans le navigateur et le controlleur appelé par la suite."
    },
    {
      "type": "markdown",
      "data": "#### Création d'une page \"à propos\""
    },
    {
      "type": "markdown",
      "data": "Pour faire un lien vers une nouvelle page, on utilise la méthode 'render'. "
    },
    {
      "type": "markdown",
      "data": "Par exemple, dans notre DefaultController :"
    },
    {
      "type": "code",
      "language": "php",
      "data": "    /**\n     * @Route(\"/about\", name=\"about\")\n     */\npublic function aboutAction() {\n        return $this->render('default/about.html.twig', [\n\n        ]);\n     }"
    },
    {
      "type": "markdown",
      "data": "On définit la route de notre page avec l'annotation @Route au-dessus de la méthode concernée."
    },
    {
      "type": "markdown",
      "data": "Le \"name\" est important. Si on veut faire référence à cette route plus tard, on l'appellera grâce à ce \"name\" là."
    },
    {
      "type": "markdown",
      "data": "Dans cette version, pas d'index.php, mais app.php (situé dans le dossier web)"
    },
    {
      "type": "markdown",
      "data": "On a aussi un point d'entrée 'app_dev.php', donc <dossier>/web/app_dev.php/about pour accéder à notre exemple."
    },
    {
      "type": "markdown",
      "data": "Maintenant, si je souhaite accéder à cette URL : /about/{prenom}\nOn peut tout simplement envoyer des paramètres à notre méthode aboutAction()"
    },
    {
      "type": "markdown",
      "data": "TRES UTILE POUR DEBUGGER LES ROUTES :\n bin/console debug:router"
    },
    {
      "type": "code",
      "language": "php",
      "data": "    /**\n     * @param string $prenom\n     * @param Request $request\n     * @return \\Symfony\\Component\\HttpFoundation\\Response\n     * @Route(\"/about/{prenom}\", name=\"aboutname\")\n     */\n   public function aboutController(string $prenom, Request $request) {\n        var_dump($prenom);\n        $prenom = ucfirst($prenom);\n        return $this->render('default/about.html.twig', [\n            'p' => $prenom\n        ]);\n        //Par ce mécanisme, je transmet la valeur de ma variable au template about\n    }"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": "(pour vider le cache, supprimer le cache dans le dossier var !)"
    },
    {
      "type": "markdown",
      "data": "[Twig](quiver-note-url/CDFDCD5D-97CC-4FAE-9B98-3B439ECCBDFF)"
    },
    {
      "type": "markdown",
      "data": "<link rel=\"stylesheet\" href={{ asset('css/style.css') }} />\u0003aa"
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    },
    {
      "type": "markdown",
      "data": ""
    }
  ]
}